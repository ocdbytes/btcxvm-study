// These constants represent the RISC-V ELF and the image ID generated by risc0-build.
// The ELF is used for proving and the ID is used for verification.
use methods::{BEE_GUEST_ELF, BEE_GUEST_ID};
use risc0_zkvm::{default_prover, ExecutorEnv};

fn main() {
    // Initialize tracing. In order to view logs, run `RUST_LOG=info cargo run`
    tracing_subscriber::fmt()
        .with_env_filter(tracing_subscriber::filter::EnvFilter::from_default_env())
        .init();

    let input: Vec<String> = vec![
        "1".to_string(),
        "2".to_string(),
        "3".to_string(),
        "OP_DUP".to_string(),
        "OP_ROT".to_string(),
        "OP_SWAP".to_string(),
    ];
    let env = ExecutorEnv::builder()
        .write(&input)
        .unwrap()
        .build()
        .unwrap();

    let prover = default_prover();

    let prove_info = prover.prove(env, BEE_GUEST_ELF).unwrap();

    let receipt = prove_info.receipt;

    let output: Vec<String> = receipt.journal.decode().unwrap();
    let decoded_output = decode_output(output);
    println!(">>> input script : {:?}", decoded_output.0);
    println!(">>> main stack : {:?}", decoded_output.0);
    println!(">>> alt stack : {:?}", decoded_output.0);

    receipt.verify(BEE_GUEST_ID).unwrap();
}

fn decode_output(output: Vec<String>) -> (Vec<String>, Vec<String>, Vec<String>) {
    let input_size = output.get(0);
    let (input_vec, n) = match input_size {
        Some(size) => {
            let n: usize = size.parse().expect("Unable to find input size");
            (output[1..n].to_vec(), n)
        }
        None => (vec![], 0),
    };

    let main_stack_size = output.get(n + 1);
    let (main_stack_vec, n) = match main_stack_size {
        Some(size) => {
            let m: usize = size.parse().expect("Unable to find input size");
            (output[n..n + m].to_vec(), n + m)
        }
        None => (vec![], 0),
    };

    let alt_stack_size = output.get(n + 1);
    let (alt_stack_vec, _n) = match alt_stack_size {
        Some(size) => {
            let m: usize = size.parse().expect("Unable to find input size");
            (output[n..n + m].to_vec(), m)
        }
        None => (vec![], 0),
    };

    (input_vec, main_stack_vec, alt_stack_vec)
}
